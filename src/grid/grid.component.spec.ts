import { Component, ViewChild } from "@angular/core";
import { async, fakeAsync, TestBed, tick } from "@angular/core/testing";
import { FilteringCondition } from "../data-operations/filtering-condition";
import { IgxGridComponent, IgxGridModule } from "./grid.component";

describe("IgxGrid", () => {

    beforeEach(async(() => {
        TestBed.configureTestingModule({
            declarations: [
                IgxGridMarkupDefinitionTestComponent,
                IgxGridngForDefinitionTestComponent,
                IgxGridTemplatedTestComponent,
                IgxGridWithAutogenerateTestComponent
            ],
            imports: [IgxGridModule]
        })
        .compileComponents();
    }));

    it("should initialize a grid with columns from markup", () => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let testInstance = fixture.componentInstance;
        let grid = testInstance.grid;

        expect(testInstance).toBeDefined();
        expect(grid).toBeDefined("Markup grid is not created");

        fixture.detectChanges();

        expect(grid.columns.length).toEqual(2, "Grid columns do not match");
        expect(grid.columns[0].field).toMatch("ID");
        expect(grid.columns[1].field).toMatch("Name");
        expect(fixture.nativeElement.querySelectorAll("tr").length).toEqual(4, "Incorrect number of grid rows");
        expect(fixture.nativeElement.querySelectorAll("table > thead > tr").length).toEqual(1, "Header row not rendered");
        expect(fixture.nativeElement.querySelectorAll("th").length).toEqual(2, "Columns not rendered correctly");
    });

    it("should initialize a grid with columns with ngFor expression", () => {
        let fixture = TestBed.createComponent(IgxGridngForDefinitionTestComponent);
        fixture.detectChanges();

        let testInstance = fixture.componentInstance;
        let grid = testInstance.grid;

        expect(testInstance).toBeDefined();
        expect(grid).toBeDefined("ngFor grid is not created");

        fixture.detectChanges();

        expect(grid.columns.length).toEqual(2, "Grid columns do not match");
        expect(grid.columns[0].field).toMatch("ID");
        expect(grid.columns[1].field).toMatch("Name");
        expect(fixture.nativeElement.querySelectorAll("tr").length).toEqual(4, "Incorrect number of grid rows");
        expect(fixture.nativeElement.querySelectorAll("table > thead > tr").length).toEqual(1, "Header row not rendered");
        expect(fixture.nativeElement.querySelectorAll("th").length).toEqual(2, "Columns not rendered correctly");
    });

    it("should initialize a grid with autogenerated columns", () => {
        let fixture = TestBed.createComponent(IgxGridWithAutogenerateTestComponent);
        fixture.detectChanges();

        let testInstance = fixture.componentInstance;
        let grid = testInstance.grid;

        expect(testInstance).toBeDefined();
        expect(grid).toBeDefined();
        expect(grid.autoGenerate).toBe(true);

        expect(grid.columns.length).toEqual(2, "Grid columns do not match");
        expect(grid.columns[0].field).toMatch("ID");
        expect(grid.columns[1].field).toMatch("Name");
        expect(fixture.nativeElement.querySelectorAll("tr").length).toEqual(4, "Incorrect number of grid rows");
        expect(fixture.nativeElement.querySelectorAll("table > thead > tr").length).toEqual(1, "Header row not rendered");
        expect(fixture.nativeElement.querySelectorAll("th").length).toEqual(2, "Columns not rendered correctly");
    });

    it("should support templating in header/cell rows", () => {
        let fixture = TestBed.createComponent(IgxGridTemplatedTestComponent);
        fixture.detectChanges();

        let testInstance = fixture.componentInstance;
        let grid = testInstance.grid;

        expect(testInstance).toBeDefined();
        expect(grid).toBeDefined("Templated grid not initialized");

        fixture.detectChanges();

        expect(grid.columns[0].bodyTemplate).toBeDefined("Column cell template not initialized");
        expect(grid.columns[0].headerTemplate).toBeDefined("Column header template not initialized");
        expect(fixture.nativeElement.querySelector("tr > td > span.mybodytemplate")).toBeDefined("Cell template not rendered");
        expect(fixture.nativeElement.querySelector("tr > th > span.myheadertemplate")).toBeDefined("Header template not rendered");
        expect(fixture.nativeElement.querySelector("tr > th > span.myheadertemplate").textContent)
            .toMatch("ID", "Header template is wrong");
        expect(fixture.nativeElement.querySelector("tr > td > span.mybodytemplate").textContent).toMatch("1", "Cell template is wrong");
    });

    it("should have ARIA attributes set correctly", () => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let nativeElement: HTMLElement = fixture.nativeElement.querySelector("table");
        let grid = fixture.componentInstance.grid;
        let thead = nativeElement.querySelector("thead");
        let tbody = nativeElement.querySelector("tbody");

        fixture.detectChanges();

        expect(nativeElement.getAttribute("role")).toMatch("grid");
        expect(nativeElement.getAttribute("aria-readonly")).toMatch("true");

        expect(thead.getAttribute("role")).toMatch("rowgroup");
        expect(thead.querySelector("tr").getAttribute("role")).toMatch("rowheader");

        expect(thead.querySelector("tr > th").getAttribute("role")).toMatch("columnheader");
        expect(tbody.querySelector("tr > td").getAttribute("role")).toMatch("gridcell");

        expect(tbody.querySelector("tr").getAttribute("role")).toMatch("row");
        expect(tbody.querySelector("tr").getAttribute("data-row")).toMatch("0");

        expect(tbody.querySelector("tr > td").getAttribute("aria-readonly")).toMatch("true");
        expect(tbody.querySelector("tr > td").getAttribute("aria-describedby")).toMatch("ID");

        expect(tbody.querySelector("tr > td").getAttribute("data-row")).toBe("0");
        expect(tbody.querySelector("tr > td").getAttribute("data-col")).toBe("0");

        // Make the first column editable
        grid.columns[0].editable = true;

        fixture.detectChanges();

        expect(nativeElement.getAttribute("aria-readonly")).toMatch("false");
        expect(tbody.querySelector("tr > td").getAttribute("aria-readonly")).toMatch("false");
    });

    it("should have the basic CRUD API working correctly", () => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let gridElement: HTMLElement = fixture.nativeElement.querySelector("table");
        let grid = fixture.componentInstance.grid;
        let data = fixture.componentInstance.data;

        // Column API
        expect(grid.getColumnByIndex(0)).toEqual(grid.columns[0]);
        expect(grid.getColumnByIndex(1000)).toBeFalsy();
        expect(grid.getColumnByField("ID")).toEqual(grid.columns[0]);
        expect(grid.getColumnByField("Not Here")).toBeFalsy();

        fixture.detectChanges();

        let newRow = {ID: 4, Name: "Test String"};

        // Row Adding
        grid.addRow(newRow);
        fixture.detectChanges();

        expect(data.length).toEqual(4, "New row added to data container");
        expect(gridElement.querySelectorAll("tbody > tr").length).toEqual(4, "New row is rendered in the grid");
        expect(gridElement.querySelector("tbody > tr:last-child > td:last-child").textContent).toMatch("Test String");

        // Row Deleting with numeric index
        grid.deleteRow(3);
        fixture.detectChanges();

        expect(data.length).toEqual(3, "Row removed from the data container");
        expect(gridElement.querySelectorAll("tbody > tr").length).toEqual(3, "Row is removed from the grid");
        expect(gridElement.querySelector("tbody > tr:last-child > td:last-child").textContent).not.toMatch("Test String");

        grid.addRow(newRow);
        fixture.detectChanges();

        expect(data.length).toEqual(4, "New row added to data container");
        expect(gridElement.querySelectorAll("tbody > tr").length).toEqual(4, "New row is rendered in the grid");
        expect(gridElement.querySelector("tbody > tr:last-child > td:last-child").textContent).toMatch("Test String");

        // Row Deleting with string index
        grid.deleteRow("3");
        fixture.detectChanges();

        expect(data.length).toEqual(3, "Row removed from the data container");
        expect(gridElement.querySelectorAll("tbody > tr").length).toEqual(3, "Row is removed from the grid");
        expect(gridElement.querySelector("tbody > tr:last-child > td:last-child").textContent).not.toMatch("Test String");

        grid.addRow(newRow);
        fixture.detectChanges();

        expect(data.length).toEqual(4, "New row added to data container");
        expect(gridElement.querySelectorAll("tbody > tr").length).toEqual(4, "New row is rendered in the grid");
        expect(gridElement.querySelector("tbody > tr:last-child > td:last-child").textContent).toMatch("Test String");

        // Row Deleting with row object
        grid.deleteRow(newRow);
        fixture.detectChanges();

        expect(data.length).toEqual(3, "Row removed from the datasource");
        expect(gridElement.querySelectorAll("tbody > tr").length).toEqual(3, "Row is removed from the grid");
        expect(gridElement.querySelector("tbody > tr:last-child > td:last-child").textContent).not.toMatch("Test String");

        grid.addRow(newRow);
        fixture.detectChanges();

        expect(data.length).toEqual(4, "New row added to datasource");
        expect(gridElement.querySelectorAll("tbody > tr").length).toEqual(4, "New row is rendered in the grid");
        expect(gridElement.querySelector("tbody > tr:last-child > td:last-child").textContent).toMatch("Test String");

        // Row updating through API
        spyOn(grid.onEditDone, "emit");
        grid.updateRow(3, {ID: 10, Name: "New Value"});
        fixture.detectChanges();

        expect(grid.onEditDone.emit).toHaveBeenCalled();
        let lastRow = gridElement.querySelector("tbody > tr:last-child");

        expect(lastRow.querySelectorAll("td")[0].textContent).toMatch("10");
        expect(lastRow.querySelectorAll("td")[1].textContent).toMatch("New Value");

        // getCell
        let cell = grid.getCell(0, 1);
        fixture.detectChanges();

        expect(cell.dataItem).toMatch("Johny");

        // getRow
        let row = grid.getRow(0);
        fixture.detectChanges();

        expect(row.row.Name).toMatch("Johny");
        expect(row.row.ID).toMatch("1");
    });

    it("should have row selection", () => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let row: HTMLElement = fixture.nativeElement.querySelector("table > tbody > tr");
        let grid = fixture.componentInstance.grid;

        spyOn(grid.onRowSelection, "emit");
        row.dispatchEvent(new Event("focus"));

        fixture.detectChanges();

        expect(row.classList.contains("selected-row")).toBe(true, "Focused row styling is not applied");
        expect(row.getAttribute("aria-selected")).toMatch("true", "Focused row ARIA attribute is not applied");
        expect(grid.onRowSelection.emit).toHaveBeenCalled();

        row.dispatchEvent(new Event("blur"));
        fixture.detectChanges();

        expect(row.classList.contains("selected-row")).toBe(false, "Focused row styling is not removed");
        expect(row.getAttribute("aria-selected")).toBe(null, "Focused row ARIA attribute is not removed");
    });

    it("should have cell selection", () => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let cell: HTMLElement = fixture.nativeElement.querySelector("tbody td");
        let grid = fixture.componentInstance.grid;

        spyOn(grid.onCellSelection, "emit");
        cell.dispatchEvent(new Event("focus"));

        fixture.detectChanges();

        expect(cell.classList.contains("selected-cell")).toBe(true, "Focused cell styling is not applied");
        expect(cell.getAttribute("aria-selected")).toMatch("true", "Focused cell ARIA attribute is not applied");
        expect(cell.parentElement.classList.contains("selected-row")).toBe(true, "Focused cell does not applies parent row styling");
        expect(grid.onCellSelection.emit).toHaveBeenCalled();

        cell.dispatchEvent(new Event("blur"));
        fixture.detectChanges();

        expect(cell.classList.contains("selected-cell")).toBe(false, "Focused cell styling is not removed");
        expect(cell.getAttribute("aria-selected")).toBe(null, "Focused cell ARIA attribute is not removed");
        expect(cell.parentElement.classList.contains("selected-row")).toBe(false, "Focused cell does not remove parent row styling");
    });

    // it("keyboard navigation", fakeAsync(() => {
    //     let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
    //     tick();
    //     fixture.detectChanges();

    //     function hasClass(element: HTMLElement, className: string) {
    //         return element.classList.contains(className);
    //     }

    //     let cells: HTMLElement[] = fixture.nativeElement.querySelectorAll("table > tbody td");

    //     cells[0].dispatchEvent(new Event("focus"));
    //     tick();
    //     fixture.detectChanges();
    //     expect(hasClass(cells[0], "selected-cell")).toBe(true, "1");

    //     cells[0].dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit>{key: "ArrowRight", bubbles: true}));
    //     tick();
    //     fixture.detectChanges();
    //     expect(hasClass(cells[1], "selected-cell")).toBe(true, "2");

    //     cells[1].dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit>{key: "ArrowLeft", bubbles: true}));
    //     tick();
    //     fixture.detectChanges();
    //     expect(hasClass(cells[0], "selected-cell")).toBe(true, "3");

    //     cells[0].dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit>{key: "ArrowDown", bubbles: true}));
    //     tick();
    //     fixture.detectChanges();
    //     expect(hasClass(cells[2], "selected-cell")).toBe(true, "4");

    //     cells[2].dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit>{key: "ArrowUp", bubbles: true}));
    //     tick();
    //     fixture.detectChanges();
    //     expect(hasClass(cells[0], "selected-cell")).toBe(true, "5");
    // }));

    it("should support column sorting", () => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let gridElement: HTMLElement = fixture.nativeElement.querySelector("table");
        let grid = fixture.componentInstance.grid;
        let firstColumn = gridElement.querySelector("thead > tr > th");

        firstColumn.dispatchEvent(new Event("click"));
        fixture.detectChanges();

        expect(firstColumn.classList.contains("asc")).toBe(false, "Column should not be sorted ascendingly");
        grid.columns[0].sortable = true;
        fixture.detectChanges();

        firstColumn.dispatchEvent(new Event("click"));
        fixture.detectChanges();

        expect(firstColumn.classList.contains("asc")).toBe(true, "Column should be sorted ascendingly");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("1");

        firstColumn.dispatchEvent(new Event("click"));
        fixture.detectChanges();

        expect(firstColumn.classList.contains("desc")).toBe(true, "Column should be sorted descendingly");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("3");

        firstColumn.dispatchEvent(new Event("click"));
        fixture.detectChanges();

        expect(firstColumn.classList.contains("off")).toBe(true, "Column sorting should be 'off'");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("3");
    });

    it("should support filetring", () => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let grid = fixture.componentInstance.grid;
        grid.columns[0].filtering = true;
        grid.columns[0].filteringCondition = FilteringCondition.number.equals;
        grid.columns[0].dataType = 1;

        fixture.detectChanges();

        let filterInputButton: HTMLElement = fixture.nativeElement.querySelector(".igx-filtering");
        let tbody: HTMLElement = fixture.nativeElement.querySelector("table > tbody");

        expect(filterInputButton).toBeTruthy();

        filterInputButton.dispatchEvent(new Event("click"));
        fixture.detectChanges();

        expect(filterInputButton.classList.contains("b-active")).toBe(true);
        let filterInput: HTMLInputElement = fixture.nativeElement.querySelector(".igx-filter-drop > input");
        expect(filterInput).toBeTruthy();

        filterInput.value = "1";
        filterInput.dispatchEvent(new Event("input"));
        fixture.detectChanges();

        expect(tbody.querySelectorAll("tr").length).toEqual(1);
        expect(tbody.querySelector("tr > td").textContent).toMatch("1");

        filterInput.value = "";
        filterInput.dispatchEvent(new Event("input"));
        fixture.detectChanges();

        expect(tbody.querySelectorAll("tr").length).toEqual(3);
        expect(tbody.querySelector("tr > td").textContent).toMatch("1");
    });

    it("should open editing modal and update data", fakeAsync(() => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let grid = fixture.componentInstance.grid;
        let data = fixture.componentInstance.data;
        let gridElement: HTMLElement = fixture.nativeElement.querySelector("table");

        grid.columns.forEach((col) => col.editable = true);

        tick();
        fixture.detectChanges();

        gridElement.querySelector("tbody td:first-child")
            .dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit> {key: "Enter", bubbles: true}));

        tick();
        fixture.detectChanges();

        expect(grid.editingModal.isOpen).toBe(true);
        let dialog = gridElement.querySelector(".igx-dialog");
        expect(dialog).toBeDefined();

        tick();
        fixture.detectChanges();

        expect(dialog.querySelectorAll("input").length).toEqual(2);
        expect(dialog.querySelectorAll("input")[0].value).toMatch("1");
        expect(dialog.querySelectorAll("input")[1].value).toMatch("Johny");
        dialog.querySelector("input").value = "10000";
        dialog.querySelector("input").dispatchEvent(new Event("input"));

        tick();
        fixture.detectChanges();

        dialog.dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit> {key: "Enter", bubbles: true}));

        tick();
        fixture.detectChanges();

        expect(grid.editingModal.isOpen).toBe(false);

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("10000");
        expect(data[0].ID).toMatch("10000");
    }));

    it("should open editing modal and not update data on cancel", fakeAsync(() => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();

        let grid = fixture.componentInstance.grid;
        let data = fixture.componentInstance.data;
        let gridElement: HTMLElement = fixture.nativeElement.querySelector("table");

        grid.columns.forEach((col) => col.editable = true);

        tick();
        fixture.detectChanges();

        gridElement.querySelector("tbody td:first-child")
            .dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit> {key: "Enter", bubbles: true}));

        tick();
        fixture.detectChanges();

        expect(grid.editingModal.isOpen).toBe(true);
        let dialog = gridElement.querySelector(".igx-dialog");
        expect(dialog).toBeDefined();

        tick();
        fixture.detectChanges();

        expect(dialog.querySelectorAll("input").length).toEqual(2);
        expect(dialog.querySelectorAll("input")[0].value).toMatch("1");
        expect(dialog.querySelectorAll("input")[1].value).toMatch("Johny");
        dialog.querySelector("input").value = "10000";
        dialog.querySelector("input").dispatchEvent(new Event("input"));

        tick();
        fixture.detectChanges();

        dialog.dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit> {key: "Escape", bubbles: true}));

        tick();
        fixture.detectChanges();

        expect(grid.editingModal.isOpen).toBe(false);

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("1");
        expect(data[0].ID).toMatch("1");
    }));

    it("should paginate data", fakeAsync(() => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();
        let grid = fixture.componentInstance.grid;
        let data = fixture.componentInstance.data;
        let gridElement: HTMLElement = fixture.nativeElement.querySelector("table");

        grid.columns.forEach((col) => col.editable = true);
        grid.rowsPerPage = 1;
        grid.paging = true;

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelectorAll("tbody tr").length).toEqual(1);
        expect(gridElement.querySelector(".igx-paginator")).toBeDefined();
        expect(grid.paginator).toBeDefined();
        expect(gridElement.querySelectorAll(".igx-paginator > button").length).toEqual(4);
        expect(gridElement.querySelector(".igx-paginator > span").textContent).toMatch("1 of 3");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("1");

        // Goto page 2
        gridElement.querySelectorAll(".igx-paginator > button")[2].dispatchEvent(new Event("click"));

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelector(".igx-paginator > span").textContent).toMatch("2 of 3");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("2");

        // Goto page 3 through API and listen for event
        spyOn(grid.onPagingDone, "emit");
        grid.paginate(2);

        tick();
        fixture.detectChanges();

        expect(grid.onPagingDone.emit).toHaveBeenCalled();
        expect(gridElement.querySelector(".igx-paginator > span").textContent).toMatch("3 of 3");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("3");

        grid.paging = false;

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelectorAll("tbody tr").length).toEqual(3);
        expect(gridElement.querySelector(".igx-paginator")).toBeFalsy();
    }));

    it("pagination with editing", fakeAsync(() => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();
        let grid = fixture.componentInstance.grid;
        let data = fixture.componentInstance.data;
        let gridElement: HTMLElement = fixture.nativeElement.querySelector("table");

        grid.columns.forEach((col) => col.editable = true);
        grid.rowsPerPage = 1;
        grid.paging = true;

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelectorAll("tbody tr").length).toEqual(1);
        expect(gridElement.querySelector(".igx-paginator")).toBeDefined();
        expect(grid.paginator).toBeDefined();
        expect(gridElement.querySelectorAll(".igx-paginator > button").length).toEqual(4);
        expect(gridElement.querySelector(".igx-paginator > span").textContent).toMatch("1 of 3");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("1");

        gridElement.querySelectorAll(".igx-paginator > button")[2].dispatchEvent(new Event("click"));

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelector(".igx-paginator > span").textContent).toMatch("2 of 3");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("2");

        gridElement.querySelector("tbody > tr > td")
            .dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit> {key: "Enter", bubbles: true}));

        tick();
        fixture.detectChanges();

        expect(grid.editingModal.isOpen).toBe(true);
        let dialog = gridElement.querySelector(".igx-dialog");
        expect(dialog).toBeDefined();

        tick();
        fixture.detectChanges();

        expect(dialog.querySelectorAll("input").length).toEqual(2);
        expect(dialog.querySelectorAll("input")[0].value).toMatch("2");
        expect(dialog.querySelectorAll("input")[1].value).toMatch("Sally");
        dialog.querySelector("input").value = "10000";
        dialog.querySelector("input").dispatchEvent(new Event("input"));

        tick();
        fixture.detectChanges();

        dialog.dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit> {key: "Enter", bubbles: true}));

        tick();
        fixture.detectChanges();

        expect(grid.editingModal.isOpen).toBe(false);

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("10000");
        expect(data[1].ID).toMatch("10000");
    }));

    it("pagination with editing 2", fakeAsync(() => {
        let fixture = TestBed.createComponent(IgxGridMarkupDefinitionTestComponent);
        fixture.detectChanges();
        let grid = fixture.componentInstance.grid;
        let data = fixture.componentInstance.data;
        let gridElement: HTMLElement = fixture.nativeElement.querySelector("table");

        grid.columns.forEach((col) => col.editable = true);
        grid.rowsPerPage = 1;
        grid.paging = true;

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelectorAll("tbody tr").length).toEqual(1);
        expect(grid.paginator).toBeDefined();
        expect(gridElement.querySelector(".igx-paginator")).toBeDefined();
        expect(gridElement.querySelectorAll(".igx-paginator > button").length).toEqual(4);
        expect(gridElement.querySelector(".igx-paginator > span").textContent).toMatch("1 of 3");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("1");

        gridElement.querySelectorAll(".igx-paginator > button")[2].dispatchEvent(new Event("click"));

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelector(".igx-paginator > span").textContent).toMatch("2 of 3");
        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("2");

        gridElement.querySelector("tbody > tr > td")
            .dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit> {key: "Enter", bubbles: true}));

        tick();
        fixture.detectChanges();

        expect(grid.editingModal.isOpen).toBe(true);
        let dialog = gridElement.querySelector(".igx-dialog");
        expect(dialog).toBeDefined();

        tick();
        fixture.detectChanges();

        expect(dialog.querySelectorAll("input").length).toEqual(2);
        expect(dialog.querySelectorAll("input")[0].value).toMatch("2");
        expect(dialog.querySelectorAll("input")[1].value).toMatch("Sally");
        dialog.querySelector("input").value = "10000";
        dialog.querySelector("input").dispatchEvent(new Event("input"));

        tick();
        fixture.detectChanges();

        dialog.dispatchEvent(new KeyboardEvent("keyup", <KeyboardEventInit> {key: "Escape", bubbles: true}));

        tick();
        fixture.detectChanges();

        expect(grid.editingModal.isOpen).toBe(false);

        tick();
        fixture.detectChanges();

        expect(gridElement.querySelector("tbody > tr > td").textContent).toMatch("2");
        expect(data[1].ID).toMatch("2");
    }));
});

@Component({
    template: `
    <igx-grid [data]="data">
        <igx-column field="ID"></igx-column>
        <igx-column field="Name"></igx-column>
    </igx-grid>
    `
})
export class IgxGridMarkupDefinitionTestComponent {

    public data = [
        {ID: 1, Name: "Johny"},
        {ID: 2, Name: "Sally"},
        {ID: 3, Name: "Tim"}
    ];

    @ViewChild(IgxGridComponent) public grid: IgxGridComponent;
}

@Component({
    template: `
    <igx-grid [data]="data">
        <igx-column *ngFor="let field of ['ID', 'Name'];" [field]="field">
        </igx-column>
    </igx-grid>
    `
})
export class IgxGridngForDefinitionTestComponent {

    public data = [
        {ID: 1, Name: "Johny"},
        {ID: 2, Name: "Sally"},
        {ID: 3, Name: "Tim"}
    ];

    @ViewChild(IgxGridComponent) public grid: IgxGridComponent;
}

@Component({
    template: `
    <igx-grid [data]="data">
        <igx-column field="ID">
            <template igxHeader let-col>
                <span class="myheadertemplate">{{ col.field }}</span>
            </template>
            <template igxCell let-item="item">
                <span class="mybodytemplate">{{ item }}</span>
            </template>
        </igx-column>
        <igx-column field="Name"></igx-column>
    </igx-grid>
    `
})
export class IgxGridTemplatedTestComponent {

    public data = [
        {ID: 1, Name: "Johny"},
        {ID: 2, Name: "Sally"},
        {ID: 3, Name: "Tim"}
    ];

    @ViewChild(IgxGridComponent) public grid: IgxGridComponent;
}

@Component({
    template: `
    <igx-grid [data]="data" [autoGenerate]="true"></igx-grid>
    `
})
export class IgxGridWithAutogenerateTestComponent {

    public data = [
        {ID: 1, Name: "Johny"},
        {ID: 2, Name: "Sally"},
        {ID: 3, Name: "Tim"}
    ];

    @ViewChild(IgxGridComponent) public grid: IgxGridComponent;
}
